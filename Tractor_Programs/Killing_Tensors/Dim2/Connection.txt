Dim2TracConn:=proc(g,k) local Q, Bf, Bv, Fv, dimvs, Gamma, R, K, listr, list2r, list3r, list4r, KA, numAr, a, A, ind, last, Comps, Comps2, Comps3, Comps4, thing, realA, detg, gin, epsilon, EPsilon, ePsilon, B, Ind, iNd, S, P, As, q, Preseq, m, n, Kfa, K2a, Kb, Kc, Kd, Eqns, Mat, BigMat, y, z, makeSymTens, numEl, MakeB, ell, MakeS, k2a, Yp, Kf2a, fud, makeSymTens2, getcomps, ans1, ans2, ans3, ans4, preseq, Qu, zero, makeSymTens3, symmetrizeTens, conTens;

Q:=DGinformation(g,"ObjectFrame"); #op(2,op(1,op(1,g))); #get the vector bundle.

Bf:=DGinformation(Q,"FrameBaseForms");
Bv:=DGinformation(Q,"FrameBaseVectors");
Fv:=DGinformation(Q,"FrameFiberVectors");
dimvs:=nops(Fv);

Gamma:=Christoffel(g);
R:=RicciScalar(g);
K:=R/2; #Sectional curvature.

listr:=[seq(k-i,i=2..k-1)];
list2r:=[seq(k-i,i=0..k-1)];
list3r:=[seq(k-i,i=0..k)];
list4r:=[seq(k-i,i=2..k)];
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];

#Begin new symmetrization stuff.

#This method should initialize the 2-d arbitrary symmetric tensors.

makeSymTens:=proc(r,s,Q) local KA,list1,tensorArray,i,listList,tens,tensorList,out;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];
list1:=KA(r);
tensorArray:=Array([]);

for i in seq(j,j=1..nops(list1)) do
listList:=combinat:-permute(list1[i],r);
tens:=_DG([["tensor", Q, [[seq("cov_bas",j=1..r)], []]], [ seq([listList[j], y||(i+s-1)],j=1..nops(listList)) ]]);
ArrayTools:-Append(tensorArray,tens);
od;

tensorList:=[seq(tensorArray[j],j=op(2,tensorArray))];
out:=evalDG(add(tensorList[j],j=1..nops(tensorList)));

end:

#The following short method gets the "starting point" for the rank n-1 tensor for the rank r connection components (need to add 1 later).

numEl:=proc(r,n)
sum((r+1-o),o=0..(r-n));
end;

#Here's the rank k tensor:

realA||k:=makeSymTens(k,1,Q);

#Now let's get the the others through rank 1. (may no longer work for rank 1 connection).

for m in seq(k-1-i,i=0..k-2) do
realA||m:=makeSymTens(m,numEl(k,m+1)+1,Q);
od;

realA||0:=DGinformation(makeSymTens(0,numEl(k,0),Q),"CoefficientSet")[1];

Comps2:=[seq(y||i,i=1..numEl(k,0))];

#End of new symmetrization stuff.

detg:=sqrt(LinearAlgebra:-Determinant(convert(g,DGMatrix)));
gin:=InverseMetric(g);
epsilon:=evalDG(detg*(Bf[1] &t Bf[2] - Bf[2] &t Bf[1]));
EPsilon:=RaiseLowerIndices(gin,epsilon,[1,2]);
ePsilon:=RaiseLowerIndices(gin,epsilon,[2]);

#Now we're going to try to define the B tensors in a clever way.

MakeB:=proc(r1,s1,Q) local makeB,makeB2,BigB;

makeB:=proc(r,s,Q) local KA,list1,tensorArray,i,listList,tens,tensorList,out,Out;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];
list1:=KA(r);

#We'll compute the first term first.

tensorArray:=Array([]);

for i in seq(j,j=2..nops(list1)) do
listList:=combinat:-permute(list1[i],r);
tens:=_DG([["tensor", Q, [[seq("cov_bas",j=1..r)], []]], [ seq([listList[j], y||(i-1+numEl(k,nops(listList[j])) )*((-detg*(i-1))/(r))],j=1..nops(listList)) ]]);
ArrayTools:-Append(tensorArray,tens);
od;

tensorList:=[seq(tensorArray[j],j=op(2,tensorArray))];
out:=evalDG(add(tensorList[j],j=1..nops(tensorList)));
Out:=evalDG(out &t Bf[1]);
return Out;
end:

makeB2:=proc(r,s,Q) local KA,list1,tensorArray,i,listList,tens,tensorList,out,Out;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];
list1:=KA(r);

#We'll compute the first term first.

tensorArray:=Array([]);

for i in seq(j,j=1..nops(list1)-1) do
listList:=combinat:-permute(list1[i],r);
tens:=_DG([["tensor", Q, [[seq("cov_bas",j=1..r)], []]], [ seq([listList[j], y||(i+numEl(k,nops(listList[j])) )*((detg*(r-i+1))/(r))],j=1..nops(listList)) ]]);
ArrayTools:-Append(tensorArray,tens);
od;

tensorList:=[seq(tensorArray[j],j=op(2,tensorArray))];
out:=evalDG(add(tensorList[j],j=1..nops(tensorList)));
Out:=evalDG(out &t Bf[2]);
return Out;
end:


#makeB(r,numEl(r,s),Q);

BigB:=evalDG(evalDG(makeB(r1,numEl(r1,s1),Q)) + evalDG(makeB2(r1,numEl(r1,s1),Q)));

end:

for ell in seq(k-j,j=0..(k-1)) do
B||(ell+1):=MakeB(ell,0,Q);
od;

#End of clever B stuff.

#Start of clever S stuff.

MakeS:=proc(r,Q) local KA,list1,ts1,tensorArray,i,listList,tens,Tens,tensorList,out,fudge;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];
list1:=KA(r);
ts1:=ContractIndices(realA||r,ePsilon,[[1,2]]);

#tensorArray:=Array([]);

tensorList:=[];

for i in seq(j,j=1..nops(list1)) do
listList:=combinat:-permute(list1[i],r);
fudge:=r/nops(listList);
tens:=_DG([["tensor", Q, [[seq("cov_bas",j=1..r)], []]], [ seq([listList[j], add( DGinformation( ts1, "CoefficientList", listList ) ) ],j=1..nops(listList)) ]]);
Tens:=evalDG(fudge*tens);
tensorList:=[seq(tensorList[j],j=1..nops(tensorList)),Tens];
od;

out:=evalDG(add(tensorList[j],j=1..nops(tensorList)));

end:

for iNd in list2r do
S||iNd:=MakeS(iNd,Q);
od;

#End of clever S stuff.

#Now we have to define the symmetric bits. We'll start with the P tensors.

################

makeSymTens3:=proc(T,Q) local k,Tcomps,KA,A,thing;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];
thing:=ListTools:-FlattenOnce([op(T)[1][3][1]]);
k:=ListTools:-Occurrences("con_bas",thing); #nops(op(T)[1][3][1]) #Rank of T.
if k>0 then
Tcomps:=DGinformation(T,"CoefficientList",KA(k));
A:=_DG([["tensor", Q, [[seq("con_bas",i=1..k)], []]], [ seq([KA(k)[i], Tcomps[i]*binomial(k,i-1)],i=1..k+1) ]]);
else 
A:=T fi;
return A;
end:

symmetrizeTens:=proc(T) local KA, thing, k, listList, Tcomps, Tcomp, tens, tensorList, A, Q, list1, i, tensorArray;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];


thing:=ListTools:-FlattenOnce([op(T)[1][3][1]]);
if type(thing[1],string) then
k:=ListTools:-Occurrences(thing[1],thing); #nops(op(T)[1][3][1]) #Rank of T.
list1:=KA(k);
tensorArray:=Array([]);
#if k>0 then
Q:=op(T)[1][2];

for i in seq(j,j=1..nops(list1)) do
listList:=combinat:-permute(list1[i],k);
Tcomps:=DGinformation(T,"CoefficientList",listList);
Tcomp:=add(Tcomps[j],j=1..nops(Tcomps))/nops(listList);
tens:=_DG([["tensor", Q, [[seq(thing[1],j=1..k)], []]], [ seq([listList[j], Tcomp],j=1..nops(listList)) ]]);
ArrayTools:-Append(tensorArray,tens);
od;

tensorList:=[seq(tensorArray[j],j=op(2,tensorArray))];
A:=evalDG(add(tensorList[j],j=1..nops(tensorList)));

else 
A:=T fi;
return A;

end:


zero:=proc(rnk)
return eval(evalDG(c*MonomialDGobject[DGtensor]([seq(1,i=1..rnk)],[[seq("con_bas",i=1..rnk)],[]],Q)),c=0);
end;

for q in seq(i,i=0..k) do
#for q in seq(i,i=0..k+k+1) do
P[k][q][-1]:=0;
od;

P[k][1][0]:=K;

for Qu in seq(i,i=1..k) do
#for Qu in seq(i,i=1..k+k+1) do
for m in seq(i,i=0..Qu-1) do
#for m in seq(i,i=0..k-1) do
(k,Qu,m);
if Qu-m>1 then
ans1:=evalDG((-1)*ContractIndices( CovariantDerivative(P[k][Qu-1][m],Gamma), EPsilon, [[Qu-1-m,2]]));
else ans1:=0 fi;

ans2:=evalDG((1)*(k+3-m)/(k+1-m)*P[k][Qu-1][m-1]);

if (Qu-3-m>=0) then
preseq:=[seq(evalDG(P[k][Qu-1][m+n+1] &t P[k][m+n+1][m]),n=0..Qu-3-m)];
ans3:=evalDG(evalDG(sum(preseq[i],i=1..nops(preseq)) &t gin));
else if Qu-m-1=0 then ans3:=0 else ans3:=zero(Qu-m-1);
fi;
fi;

if Qu-m-1=0 then
ans4:=(1)*P[k][1][0];
else ans4:=zero(Qu-m-1) fi;

if Qu-m>1 then
#P[k][Qu][m]:=SymmetrizeIndices(evalDG(ans1+ans2+ans3+ans4),[seq(i,i=1..Qu-m-1)],"Symmetric");
P[k][Qu][m]:=makeSymTens3(symmetrizeTens(evalDG(ans1+ans2+ans3+ans4)),Q);
else
P[k][Qu][m]:=evalDG( ans1 + ans2 + ans3 + ans4) fi;

od;
od;

#We consider the P tensors to be defined. With the S tensors also defined, we can give the symmetric bits.

As||(k):=_DG([["tensor", Q, [[seq("cov_bas",i=1..k+1)], []]], [[[seq(1,i=1..k+1)], 0]]]);
for q in seq(i,i=1..k) do
#Preseq:=[seq(evalDG(ContractIndices(S||((k-q)+q-m), P[k][q][m],[seq([i,i],i=1..q-m-1)])),m=0..q-1)];
Preseq:=[seq(evalDG(ContractIndices(makeSymTens3(S||((k-q)+q-m),Q), P[k][q][m],[seq([i,i],i=1..q-m-1)])),m=0..q-1)];
As||(k-q):=evalDG(evalDG(sum(Preseq[i],i=1..nops(Preseq))) );
od;

makeSymTens2:=proc(k,s,Q) local KA,A;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];
A:=_DG([["tensor", Q, [[seq("cov_bas",i=1..k)], []]], [ seq([KA(k)[i], y||(i+s)*binomial(k,i-1)],i=1..k+1) ]]);
end:

#We use the getcomps procedure to fudge the symmetric covariant derivative.

getcomps:=proc(T,listList) local complist,k,i,perms,co1,co2;
complist:=Array([]);
k:=nops(listList[1]);
for i in seq(j,j=1..nops(listList)) do
perms:=combinat:-permute(listList[i],k);
co1:=DGinformation(T,"CoefficientList",perms);
co2:=simplify(add(co1)/binomial(k,i-1));
ArrayTools:-Append(complist,co2);
od;
[seq(complist[j],j=op(2,complist))];
end:

#Here's the last bit: putting it all together.

for m in seq(i,i=1..2) do
for n in list2r do

A||n:=makeSymTens2(n,numEl(k,n+1),Q);
Kfa||n:=DirectionalCovariantDerivative(Bv[m],A||n,Gamma);
K2a||n:=getcomps(Kfa||n,KA(n));
Kb||n:=DGinformation(As||n,"CoefficientList",[seq(ListTools:-FlattenOnce([a,m]),a=KA(n))]);
Kc||n:=DGinformation(B||(n+1),"CoefficientList",[seq(ListTools:-FlattenOnce([a,m]),a=KA(n))]);
Kd||n:=seq(K2a||n[i]+Kb||n[i]+Kc||n[i],i=1..nops(Kb||n));

od;

Kfa||0:=DirectionalCovariantDerivative(Bv[m],realA||0,Gamma);
K2a||0:= Kfa||0; #[seq( DGinformation(Kfa||0,"CoefficientList",[a])[1],a=KA(0))];
Kb||0:=DGinformation(As||0,"CoefficientList",[seq(ListTools:-FlattenOnce([a,m]),a=KA(0))]);
Kc||0:=0; #DGinformation(B||(0+1),"CoefficientList",[seq(ListTools:-FlattenOnce([a,m]),a=KA(0))]);
Kd||0:=seq(K2a||0[i]+Kb||0[i]+Kc||0[i],i=1..nops(Kb||0));

Eqns||m:=[seq(Kd||(k-i),i=0..k)];
Mat||m:=evalDG(LinearAlgebra:-GenerateMatrix(Eqns||m,Comps2)*Bf[m]);

od;

BigMat:=add(Mat||i,i=1..2);
conTens:=convert(BigMat,DGtensor,[["con_vrt","cov_vrt"],[]]);
#Connection(BigMat);
Connection(conTens);

end:

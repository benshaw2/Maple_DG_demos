rnk1TracConn:=proc(Gamma, curvatureTensor:="") local Bv,Bf,CT,dimbase,Fv,X1,Y1,numX,X,X2,Y2,numW,W,getsome,XA,WA,Comps,Comps2,Comps3,Comps4,realX,realW,XR,Xc2,Xc1,Wc2,Wc1,Xc1b,Xc1c,Wc1b,Wc1c,m,BigMat;

#Bv:=DGinformation(T,"FrameBaseVectors"); # we used to require the name of the bundle.
#Bf:=DGinformation(T,"FrameBaseForms");
Bv:=DGinformation("FrameBaseVectors");
Bf:=DGinformation("FrameBaseForms");

#CT:=CurvatureTensor(Gamma);
if DGinformation(curvatureTensor, "ObjectType")="tensor" then CT:=curvatureTensor else CT:=CurvatureTensor(Gamma) fi;

dimbase:=nops(Bv);
Fv:=DGinformation("FrameFiberVectors");

#First, create an arbitrary vector:

X1:=GenerateDGobjects[DGtensors]([["cov_bas"],[]]);
Y1:=DGbasis([seq(Tensor:-YoungSymmetrizer(a, Matrix([[1]])), a = X1)]);
numX:=nops(Y1);
X:=DGzip([seq(z||i,i=1..numX)],Y1,"plus");

#Now, create an arbitrary rank 2 tensor with the required symmetry.

X2:=GenerateDGobjects[DGtensors]([["cov_bas","cov_bas"],[]]);
Y2:=DGbasis([seq(Tensor:-YoungSymmetrizer(a, Matrix([[1],[2]])), a = X2)]);
numW:=nops(Y2);
W:=DGzip([seq(z||i,i=1+numX..numX+numW)],Y2,"plus");

#The following procedure is a bit overkill for the Killing vector case. It is intended to give us the index list from which we pick off the independent components of each tensor defined above.

getsome:=proc(T,Y) local A,B,g,A2,inds,B2,thing,bracket,term;
A:=Array([]);
for thing in op(2,op(T)) do
if nops(op(1,op(1,thing[2]))) = 2 then ArrayTools:-Append(A,op(1,thing));
fi;
od;
B:=[seq(A[i],i=op(2,A))];
#we now have the bads.
g:=seq(op(2,op(Y[i])),i=1..nops(Y));
A2:=Array([]);
inds:=seq([seq(g[j][i][1],i=1..nops(g[j]))],j=1..nops([g]));
for bracket in inds do
for term in bracket do
if has(B,[term])=false then if has(A2,bracket)=false then ArrayTools:-Append(A2,[term]);
fi;
fi;
od;
od;
B2:=ListTools:-FlattenOnce([seq(A2[i],i=op(2,A2))]);
end;

XA:=getsome(X,Y1);
#if dimbase = 2 then XA:= [1,2] else XA:=getsome(X,Y1) fi;
if dimbase = 2 then WA:=[[1,2]] else WA:=getsome(W,Y2) fi;
#WA:=getsome(W,Y2);

#Now, we will get rid of the scalars: terms like z12/2 will be turned into y12.

Comps:=ListTools:-FlattenOnce([[seq(DGinformation(X,"CoefficientList",[a])[1],a=XA)],[seq(DGinformation(W,"CoefficientList",[a])[1],a=WA)]]);
Comps2:=[seq(y||i,i=1..nops(Comps))];
Comps3:=[seq(Comps[i] = Comps2[i], i=1..nops(Comps))];
Comps4:=solve(Comps3,{seq(z||i,i=1..nops(Comps))});

realX:=evalDG(simplify(subs(Comps4,X)));
realW:=evalDG(simplify(subs(Comps4,W)));

XR:=ContractIndices(CT,realX,[[1,1]]);

#Now, we build each piece to the matrix of 1-forms.

for m in seq(i,i=1..dimbase) do
Xc1b:=DirectionalCovariantDerivative(Bv[m],realX,Gamma);
Xc1c:=[seq( DGinformation(Xc1b,"CoefficientList",[[a[1]]])[1],a=XA)];
Xc2:=[seq(DGinformation(realW,"CoefficientList",[[a[1],m]])[1], a=XA)];
Xc1:=[seq(Xc2[i]+Xc1c[i],i=1..nops(Xc1c))];

Wc1b:=DirectionalCovariantDerivative(Bv[m],realW,Gamma);
Wc1c:=[seq( DGinformation(Wc1b,"CoefficientList",[[a[1],a[2]]])[1],a=WA)];
Wc2:=[seq(DGinformation(XR,"CoefficientList",[[m,a[2],a[1]]])[1], a=WA)];
Wc1:=[seq(Wc2[i] +Wc1c[i],i=1..nops(Wc1c))];

Eqns||m:=ListTools:-Flatten([Xc1,Wc1]);
Mat||m:=evalDG(LinearAlgebra:-GenerateMatrix(Eqns||m,Comps2)*Bf[m]);
od;

#Lastly, we will piece together the matrix and build the connection from it.

BigMat:=add(Mat||i,i=1..dimbase);
Connection(BigMat);
end:

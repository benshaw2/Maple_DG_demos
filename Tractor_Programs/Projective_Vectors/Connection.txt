ProjVTracConn:=proc(g, connection:="", curvatureTensor:="", ricciTensor:="", inverseMetric:="") local T, Bv, Bf, Gamma, CT, RT, RS, dimbase, Fv, X1, Y1, numX, X, X2, Y2, getsome, XA, FA, Comps, Comps2, Comps3, Comps4, realX, XR, Xc2, Xc1, Wc2, Wc1, Xc1b, Xc1c, zee1, zee2, zee3, gZ, ZA, m, BigMat, gin, H, numY, F, Z, YA, realH, realF, realZ, Xc3, Hc1b, Hc1c, Hc2, Hc3, Hc4, Hc1, Fc2, Fc1, Fc3, Fc4, Fc1b, Fc1c, Zc1b, Zc1c, Zc1, Zc2, Zc3, Zc4, Zc5, numF, Y3, numH, HA;

T:=DGinformation(g, "ObjectFrame");
Bv:=DGinformation(T,"FrameBaseVectors"); # used to require that the vector bundle was specified.
Bf:=DGinformation(T,"FrameBaseForms");

# limited support for the optional arguments.
if DGinformation(connection, "ObjectType")="connection" then Gamma:=connection else Gamma:=Christoffel(g) fi;
if DGinformation(curvatureTensor, "ObjectType")="tensor" then CT:=curvatureTensor else CT:=CurvatureTensor(Gamma) fi;
if DGinformation(ricciTensor, "ObjectType")="tensor" then RT:=ricciTensor else RT:=RicciTensor(g) fi;
if DGinformation(inverseMetric, "ObjectType")="tensor" then gin:=inverseMetric else gin:=InverseMetric(g) fi;

dimbase:=nops(Bv);
Fv:=DGinformation(T, "FrameFiberVectors");

#First, create an arbitrary vector:

X1:=GenerateDGobjects[DGtensor]([["cov_bas"],[]]);
#Y1:=DGbasis([seq(Tensor:-YoungSymmetrizer(a, Matrix([[1]])), a = X1)]);
#numX:=nops(Y1);
numX:=nops(X1);
#X:=DGzip([seq(z||i,i=1..numX)],Y1,"plus");
X:=DGzip([seq(z||i,i=1..numX)],X1,"plus");

#Now, create an arbitrary rank 2 symmetric tensor. This is H.

X2:=GenerateDGobjects[DGtensor]([["cov_bas","cov_bas"],[]]);
Y2:=DGbasis([seq(Tensor:-YoungSymmetrizer(a, Matrix([[1,2]])), a = X2)]);
numH:=nops(Y2);
H:=DGzip([seq(z||i,i=1+numX..numX+numH)],Y2,"plus");

#Now, create an arbitrary rank 2 skew symmetric tensor. This is F.

Y3:=DGbasis([seq(Tensor:-YoungSymmetrizer(a, Matrix([[1],[2]])), a = X2)]);
numF:=nops(Y3);
F:=DGzip([seq(z||i,i=1+numX+numH..numX+numH+numF)],Y3,"plus");

Z:=DGzip([seq(z||i,i=1+numX+numH+numF..numX+numH+numF+dimbase)],X1,"plus");

#The following procedure is a bit overkill for the Killing vector case. It is intended to give us the index list from which we pick off the independent components of each tensor defined above.

getsome:=proc(T,Y) local A,B,g,A2,inds,B2,thing,bracket,term;
A:=Array([]);
for thing in op(2,op(T)) do
if nops(op(1,op(1,thing[2]))) = 2 then ArrayTools:-Append(A,op(1,thing));
fi;
od;
B:=[seq(A[i],i=op(2,A))];
#we now have the bads.
g:=seq(op(2,op(Y[i])),i=1..nops(Y));
A2:=Array([]);
inds:=seq([seq(g[j][i][1],i=1..nops(g[j]))],j=1..nops([g]));
for bracket in inds do
for term in bracket do
if has(B,[term])=false then if has(A2,bracket)=false then ArrayTools:-Append(A2,[term]);
fi;
fi;
od;
od;
B2:=ListTools:-FlattenOnce([seq(A2[i],i=op(2,A2))]);
end;

XA:=getsome(X,X1);
#if dimbase = 2 then XA:= [1,2] else XA:=getsome(X,Y1) fi;
#if dimbase = 2 then HA:=[[1,2]] else HA:=getsome(H,Y2) fi;
HA:=getsome(H,Y2);
if dimbase = 2 then FA:=[[1,2]] else FA:=getsome(F,Y3) fi;
ZA:=getsome(Z,X1);
#WA:=getsome(W,Y2);

#Now, we will get rid of the scalars: terms like z12/2 will be turned into y12.

Comps:=ListTools:-FlattenOnce([[seq(DGinformation(X,"CoefficientList",[a])[1],a=XA)],[seq(DGinformation(H,"CoefficientList",[a])[1],a=HA)], [seq(DGinformation(F,"CoefficientList",[a])[1],a=FA)], [seq(DGinformation(Z,"CoefficientList",[a])[1],a=ZA)]]);
Comps2:=[seq(y||i,i=1..nops(Comps))];
Comps3:=[seq(Comps[i] = Comps2[i], i=1..nops(Comps))];
Comps4:=solve(Comps3,{seq(z||i,i=1..nops(Comps))});

realX:=evalDG(simplify(subs(Comps4,X)));
realH:=evalDG(simplify(subs(Comps4,H)));
realF:=evalDG(simplify(subs(Comps4,F)));
realZ:=evalDG(simplify(subs(Comps4,Z)));

# Now it's time to get into the equations.

# These are just some pre-computed terms.
gZ:=evalDG(g &t realZ);
XR:=ContractIndices(CT,realX,[[1,1]]);
zee1:= ContractIndices(CovariantDerivative(RT,Gamma), ContractIndices(gin, realX, [[1,1]]), [[3,1]]); #ContractIndices(evalDG(gin &t SymmetrizeIndices(CovariantDerivative(CT,Gamma), [2,3], "Symmetric") &t realX), [[1,6], [2,7], [3,8]]);
zee2:=ContractIndices(evalDG(1/2*realH + realF), RaiseLowerIndices(gin, RT,[1]), [[1,1]]);
zee3:=ContractIndices(evalDG(gin &t realH &t CT), [[2,3],[4,5],[1,6]]);
#zee3a:=ContractIndices(gin, CT, [[1,2]]);
#zee3b:=ContractIndices(realH,zee3a,[[1,1],[2,2]]);
#zee3:=zee3b; #this is 0, actually.

#Now, we build each piece to the matrix of 1-forms.

for m in seq(i,i=1..dimbase) do
Xc1b:=DirectionalCovariantDerivative(Bv[m],realX,Gamma); #cov derivative of X.
Xc1c:=[seq( DGinformation(Xc1b,"CoefficientList",[[a[1]]])[1],a=XA)]; # previous part continued.
Xc2:=[seq(DGinformation(evalDG(1/2*realH),"CoefficientList",[[a[1],m]])[1], a=XA)]; # first term on the right.
#Xc3:=[seq(DGinformation(realF,"CoefficientList",[[m,a[1]]])[1],a=XA)]; # second term on the right.
Xc3:=[seq(DGinformation(realF,"CoefficientList",[[a[1],m]])[1],a=XA)]; # second term on the right.
Xc1:=[seq(-Xc2[i]-Xc3[i]+Xc1c[i],i=1..nops(Xc1c))]; # putting it all together.

Hc1b:=DirectionalCovariantDerivative(Bv[m],realH,Gamma);
Hc1c:=[seq( DGinformation(Hc1b,"CoefficientList",[[a[1],a[2]]])[1],a=HA)];
Hc2:=[seq(DGinformation(evalDG(2*gZ),"CoefficientList",[[a[1],a[2],m]])[1], a=HA)]; # first term on the right.
Hc3:=[seq(DGinformation(gZ,"CoefficientList",[[m,a[1],a[2]]])[1],a=HA)]; #second term on the right.
Hc4:=[seq(DGinformation(gZ,"CoefficientList",[[m,a[2],a[1]]])[1],a=HA)]; #third term on the right.
Hc1:=[seq(-Hc2[i] - Hc3[i] - Hc4[i] + Hc1c[i],i=1..nops(Hc1c))];

Fc1b:=DirectionalCovariantDerivative(Bv[m],realF,Gamma);
Fc1c:=[seq( DGinformation(Fc1b,"CoefficientList",[[a[1],a[2]]])[1],a=FA)];
Fc2:=[seq(DGinformation(XR,"CoefficientList",[[m,a[2],a[1]]])[1], a=FA)]; # first term on the right.
Fc3:=[seq(DGinformation(evalDG(1/2*gZ),"CoefficientList",[[m,a[1],a[2]]])[1],a=FA)]; #second term on the right.
Fc4:=[seq(DGinformation(evalDG(-1/2*gZ),"CoefficientList",[[m,a[2],a[1]]])[1],a=FA)]; #third term on the right.
Fc1:=[seq(-Fc2[i] - Fc3[i] - Fc4[i] + Fc1c[i],i=1..nops(Fc1c))];

Zc1b:=DirectionalCovariantDerivative(Bv[m],realZ,Gamma);
Zc1c:=[seq( DGinformation(Zc1b,"CoefficientList",[[a[1]]])[1],a=XA)];
Zc2:=[seq(DGinformation(evalDG(-1/(dimbase-1)*zee1),"CoefficientList",[[b[1],m]])[1], b=XA)]; #first term.
Zc3:=[seq(DGinformation(evalDG(-1/(dimbase-1)*zee2),"CoefficientList",[[b[1],m]])[1], b=XA)]; #second term.
Zc4:=[seq(DGinformation(evalDG(-1/(dimbase-1)*zee2),"CoefficientList",[[m,b[1]]])[1], b=XA)]; #third term.
#Zc5:=[seq(DGinformation(evalDG((q)/(4*(dimbase+1))*zee3),"CoefficientList",[[m,b[1]]])[1], b=XA)]; #fourth term. just 0 always.
#Zc1:=[seq((-1)*Zc2[i] + (-1)*Zc3[i] + (-1)*Zc4[i] + (0)*Zc5[i] + (1)*Zc1c[i],i=1..nops(Zc1c))];
Zc1:=[seq(-Zc2[i] -Zc3[i] -Zc4[i] + Zc1c[i],i=1..nops(Zc1c))];
#[seq(0,i=1..dimbase)];

Eqns||m:=ListTools:-Flatten([Xc1,Hc1,Fc1,Zc1]);
Mat||m:=evalDG(LinearAlgebra:-GenerateMatrix(Eqns||m,Comps2)*Bf[m]);
od;

#Lastly, we will piece together the matrix and build the connection from it.

BigMat:=add(Mat||i,i=1..dimbase);
#Connection(BigMat);
Connection(convert(BigMat,DGtensor,[["con_vrt","cov_vrt"],[]]));
end:


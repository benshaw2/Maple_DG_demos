################################################################################

MaxKT:=proc(m,n)
# dimension m, rank n. Size of Killing tensor fibers.
((m+n-1)!*(m+n)!)/((m-1)!*m!*n!*(n+1)!);
end:

#################################################################################

MaxKY:=proc(n,k) local numF,numF1;
# dimension n, rank k. Size of Killing-Yano tensor fibers.
numF:=binomial(n,k);
numF1:=binomial(n,k+1);
numF+numF1;
end:

#################################################################################

MaxSym:=proc(m,n)
# dimension m, rank n.
#Calculates the number of independent components of a completely symmetric tensor.
(m+n-1)!/(n!*(m-1)!)
end:

#############################################################################

MaxSkew:=proc(m,n)
# dimension m, rank n.
#Calculates the number of independent components of a completely skew-symmetric tensor (should be the binomial formula).
m!/(n!*(m-n)!);
end:

####################################################################

MaxCF:=proc(n,p);
#Calculates the maximum number of conformal Killing forms in n dimensions of rank p.
binomial(n+2,p+1);
end:

########################################################################

MaxPV:=proc(m);
# dimension of the projective vector fibers.
m*(m+2);
end:

#######################################################################

KYtoKT:=proc(g,gin,KY1,KY2) local r,s1,s2;
#converts two Killing Yano tensors to a Killing tensor of rank 2.
r:=op(KY1)[1][3];
s1:=evalDG((-1)^(r-1)*TensorInnerProduct(g,KY1,KY2,inversemetric=gin,tensorindices=[seq(i,i=1..r-1)]));
s2:=SymmetrizeIndices(s1,[1,2],"Symmetric");
end:

########################################################################

CKVtoKT:=proc(X,g) local s1,gin,Xu,F,s2,s3;
# converts a conformal Killing (covariant) vector to a Killing tensor of rank 2.
s1:=evalDG(X &t X);
gin:=InverseMetric(g);
Xu:=RaiseLowerIndices(gin,X,[1]);
F:=ContractIndices(Xu,X,[[1,1]]);
s2:=evalDG(F*g);
s3:=evalDG(s1-s2);
end:


#####################################################################

ProjectiveCovariantVectors:=proc(G) local Gamma, Q, Bf, dim, vars, CT, Gin, CT1, _f, _h, X, Xr, phi, m1a, m2a, m3a, eq1a, eq2a, sol, vec, _b, _B, vecs, ZERO;
# pdsolve to get (covariant) projective vectors.
Gamma:=Christoffel(G);
Q:=DGinformation(G,"ObjectAttributes")[2];
Bf:=DGinformation(Q,"FrameBaseForms");
dim:=nops(Bf);
vars:=seq(DGinformation(Q,"FrameGlobals")[i],i=1..dim);
CT:=CurvatureTensor(Gamma);
Gin:=InverseMetric(G);
CT1:=RaiseLowerIndices(G,CT,[1]);
X:=DGzip([seq(_f||i(vars),i=1..dim)],Bf,"plus");
Xr:=RaiseLowerIndices(Gin,X,[1]);
phi:=DGzip([seq(_h||i(vars),i=1..dim)],Bf,"plus");
m1a:=CovariantDerivative(CovariantDerivative(X,Gamma),Gamma);
m2a:=ContractIndices(CT1,Xr,[[4,1]]);
m3a:=evalDG(2*SymmetrizeIndices(evalDG(G &t phi),[2,3],"Symmetric"));
eq1a:=m1a-m2a-m3a;
eq2a:=DGinformation(eq1a,"CoefficientSet");
sol:=pdsolve(eq2a);
vec:=evalDG(eval(X,sol));

_b:=1;
while has(vec,_C||(_b)) do 
_B:=_b;
_b:=_B+1;
od;

vecs:=[seq(eval(vec,[seq(_C||i=0,i=0..j-1),_C||j=1,seq(_C||k=0,k=j+1.._b-1)]),j=1.._b-1)];
ZERO:=eval(evalDG(c*Bf[1]),c=0);
[seq(evalDG(vecs[i]+ZERO),i=1..nops(vecs))];

end proc;


#####################################################################
#####################################################################


getKT2:=proc(k,Man,{output:=[]}) local p,list1,list2,list3,inf,c1,c2,g,A,n,f,flist,Y,numK,KA,ak,Ak,Comps5,ZERO,RealK,f2list,Comps6,RealK2,Result,makeSymTens;
# This returns the 2-d metric and irreducible Killing tensors of rank k for the special examples.
p:=(2*(-1)^k)/k;
list1:=[seq(i,i=2..k)];
list2:=[seq(i,i=1..k)];
list3:=[seq(i,i=1..k+1)];
inf:=DGinformation(Man,"FrameGlobals");

c1:=inf[1];
c2:=inf[2];

g:=evalDG(c1^p*(inf[-2] &t inf[-2] + inf[-1] &t inf[-1]));

#First, define the A's.

A[1][0]:=1;
A[0][0]:=0;
A[1][1]:=0;
A[0][1]:=0;
A[0][2]:=0;
A[1][2]:=0;

for n in list1 do
A[n][0]:=(k-n+3)*A[n-2][0]/(n-1);
od;

for n in list1 do
A[n][1]:=(2*A[n-1][0]+p*(k-n+3)*A[n-2][1])/(p*(n-1)-2);
od;

for n in list1 do
A[n][2]:=(2*A[n-1][1]+p*(k-n+3)*A[n-2][2])/(p*(n-1)-4);
od;

#Now, define the f's.

if type(k,odd) then
for n in list2 do

if type(n,odd) then
f[n]:=A[n][0]*c2*c1^((-1)^k);
fi;

if type(n,even) then
f[n]:=A[n][1]*c1^((-1)^k+1);
fi;

od;

f[k+1]:=-1/(2*k)*(k*A[k][0]-2*A[k-1][1]) + 1/k*A[k][0]*(c2^2)/2*c1^(-2);

fi;

if type(k,even) then
for n in list2 do

if type(n,odd) then
f[n]:=A[n][0]*(c2^2)/2*c1^((-1)^k) + A[n][2]*c1^((-1)^k+2);
fi;

if type(n,even) then
f[n]:=A[n][1]*c2*c1^((-1)^k+1);
fi;

od;

f[k+1]:=2/k*A[k-1][0]*c1*(c2^2)/2 - (A[k][1] + 2/k*A[k-1][2])*c1^3;

fi;

flist:=[seq(f[i],i=list3)];
f2list:=map(diff,flist,c2);

#If the user just wants the list of f's (and the metric), they have the option.

if output = ["list"] then return
[g,[flist,f2list]];

elif output = ["DGsymmetrictensor"] then

#_DG([["tensor", Man, [[seq("cov_bas", i=1..k)], []]], [ [[1,1],0] ]]);
RealK:=_DG([["symmetrictensor", Man, [[seq("cov_bas", i=1..k)], []]], [ seq([[seq(1,i=0..k-n), seq(2,i=0..n-2)], f[n]],n=1..k+1) ]]);
#T1:=SymmetrizeIndices(t1,[seq(i,i=1..k)],"Symmetric");
RealK2:=_DG([["symmetrictensor", Man, [[seq("cov_bas", i=1..k)], []]], [ seq([[seq(1,i=0..k-n), seq(2,i=0..n-2)], f2list[n]],n=1..k+1) ]]);
Result:=[g,[RealK,RealK2]];

elif output = ["DGyoungtensor"] then

Y:=GenerateDGobjects[DGyoungtensors]("cov_bas",[k]);
RealK:=DGzip([seq(flist[i],i=1..nops(flist))],Y,"plus");
RealK2:=DGzip([seq(flist[i],i=1..nops(flist))],Y,"plus");
Result:=[g,[RealK,RealK2]];

else

#If output=["list"] is not used, the program will try to return the actual kt's instead of just the list of components in the basis of symmetric tensors.
#this part basically uses the getDim2kt command.

#Y:=GenerateDGobjects[DGsymmetrictensors]([inf[-4],inf[-3]],k);
#numK:=nops(Y);

#Ak:=DGzip([seq(z||i,i=1..numK)],Y,"plus");

KA:=[seq([seq(1,i=1..k-j),seq(2,i=1..j)],j=0..k)];

makeSymTens:=proc(r,s,Q) local KA,list1,tensorArray,i,listList,tens,tensorList,out;
KA:=r->[seq([seq(1,i=1..r-j),seq(2,i=1..j)],j=0..r)];
list1:=KA(r);
tensorArray:=Array([]);

for i in seq(j,j=1..nops(list1)) do
listList:=combinat:-permute(list1[i],r);
tens:=_DG([["tensor", Q, [[seq("cov_bas",j=1..r)], []]], [ seq([listList[j], z||(i+s-1)/binomial(k,i-1)],j=1..nops(listList)) ]]);
ArrayTools:-Append(tensorArray,tens);
od;

tensorList:=[seq(tensorArray[j],j=op(2,tensorArray))];
out:=evalDG(add(tensorList[j],j=1..nops(tensorList)));

end:

#ak:=_DG([["tensor", Man, [[seq("cov_bas",i=1..k)], []]], [ seq([KA[i], z||i],i=1..k+1) ]]);
#Ak:=SymmetrizeIndices(ak,[seq(i,i=1..k)],"Symmetric");

#A:=_DG([["tensor", Man, [[seq("cov_bas",i=1..k)], []]], [ seq([KA(k)[i], y||(i+0)/binomial(k,i-1)],i=1..k+1) ]]);

Ak:=makeSymTens(k,1,Man);

Comps5:=[seq(z||i = flist[i],i=1..nops(flist))];
ZERO:=_DG([["tensor", Man, [[seq("cov_bas",i=1..k)], []]], [[[seq(1,i=1..k)], 0]]]);

RealK:=evalDG(evalDG(simplify(subs(Comps5,Ak)))+ZERO);

#We have now defined the first (probably irreducible) KT. Now get the second.

Comps6:=[seq(z||i = f2list[i], i=1..nops(f2list))];
RealK2:=evalDG(evalDG(simplify(subs(Comps6,Ak)))+ZERO);

Result:=[g,[RealK,RealK2]];
fi;
end:


########################################################################

KillingTensorLibrary:=module() export ModuleApply;

#The following read command would read in the entire database, which is now quite large. Thus, this program has been amended to read in only the file required.

#read "Database_table.txt";

ModuleApply := proc(n,name,{output:=[]}) local filename,filenamestr,C,V,out1,out2,name2,list,list2,list3; # name of manifold.

filename:= kt||n;
#filenamestr:=cat("kt_entries/",cat(convert(filename,string),".txt"));
filenamestr:=cat("/home/ben/kt_entries/",cat(convert(filename,string),".txt"));
read filenamestr;

V := Ben[n]["Coordinates"];
DGEnvironment[Coordinate](V,name);
C := Ben[n]["Metric"];
if output <> [] then out1:=op(1,output) fi;
if nops(output) >= 2 then out2:=op(2,output) fi;
if nops(output) >= 3 then name2:=op(3,output) fi;

if output = [] then return
_DG([["tensor",name,[["cov_bas","cov_bas"],[]]],C]); #change the lprint to name;
fi;

if type(out1,integer) then #return #then return the irreducible killing tensors of order k.
list:=Ben[n]["IrreducibleKillingTensors",out1];
return [seq(_DG([["tensor",name,[[seq("cov_bas",i=1..out1)],[]]],list[j]]),j=1..nops(list))];
fi;

if output = ["KillingTensors",out2] then
list:=Ben[n][out1,out2];
return [seq(_DG([["tensor",name,[[seq("cov_bas",i=1..out2)],[]]],list[j]]),j=1..nops(list))];
fi;

if output = ["KillingYanoTensors",out2] then
list:=Ben[n][out1,out2];
return [seq(_DG([["form",name,out2],list[j]]),j=1..nops(list))];
fi;

if output = ["ConformalKillingForms",out2] then
list:=Ben[n][out1,out2];
return [seq(_DG([["form",name,out2],list[j]]),j=1..nops(list))];
fi;

if output = ["IrreducibleRank"] then
list:=[seq(lhs(op(op(Ben)[n])[i]),i=1..nops(op(op(Ben)[n])))];
list2:=[ListTools:-SearchAll("IrreducibleKillingTensors",list)];
list3:=[seq(list[list2[i]+1],i=1..nops(list2))];
return list3;
fi;

if output = ["Notes"] then return Ben[n]["Notes"] fi;
if output = ["Reference"] then return Ben[n]["Reference"] fi;
if output = ["Coordinates"] then return Ben[n]["Coordinates"] fi;

if output = ["TractorConnection",out2,name2] then
DGEnvironment[VectorSpace](MaxKT(nops(Ben[n]["Coordinates"]),out2),name2_vs);
DGEnvironment[VectorBundle](name,name2_vs,name2);
return 
_DG([["connection", name2, [["con_vrt", "cov_vrt", "cov_bas"], []]], Ben[n]["TractorConnection",out2]]);
fi;

if output = ["TractorCurvature",out2,name2] then
DGEnvironment[VectorSpace](MaxKT(nops(Ben[n]["Coordinates"]),out2),name2_vs);
DGEnvironment[VectorBundle](name,name2_vs,name2);
return 
_DG([["tensor", name2, [["con_vrt", "cov_vrt", "cov_bas", "cov_bas"], []]], Ben[n]["TractorCurvature",out2]]);
fi;

if output = ["YanoTractorConnection",out2,name2] then
DGEnvironment[VectorSpace](MaxKY(nops(Ben[n]["Coordinates"]),out2),name2_vs);
DGEnvironment[VectorBundle](name,name2_vs,name2);
return 
_DG([["connection", name2, [["con_vrt", "cov_vrt", "cov_bas"], []]], Ben[n]["YanoTractorConnection",out2]]);
fi;

if output = ["YanoTractorCurvature",out2,name2] then
DGEnvironment[VectorSpace](MaxKY(nops(Ben[n]["Coordinates"]),out2),name2_vs);
DGEnvironment[VectorBundle](name,name2_vs,name2);
return 
_DG([["tensor", name2, [["con_vrt", "cov_vrt", "cov_bas", "cov_bas"], []]], Ben[n]["YanoTractorCurvature",out2]]);
fi;

if output = ["ConformalFormTractorConnection",out2,name2] then
DGEnvironment[VectorSpace](MaxCF(nops(Ben[n]["Coordinates"]),out2),name2_vs);
DGEnvironment[VectorBundle](name,name2_vs,name2);
return 
_DG([["connection", name2, [["con_vrt", "cov_vrt", "cov_bas"], []]], Ben[n]["ConformalFormTractorConnection",out2]]);
fi;

if output = ["ConformalFormTractorCurvature",out2,name2] then
DGEnvironment[VectorSpace](MaxCF(nops(Ben[n]["Coordinates"]),out2),name2_vs);
DGEnvironment[VectorBundle](name,name2_vs,name2);
return 
_DG([["tensor", name2, [["con_vrt", "cov_vrt", "cov_bas", "cov_bas"], []]], Ben[n]["ConformalFormTractorCurvature",out2]]);
fi;
end proc;

end module:

#####################################################

BundleLift:=proc(T,Q) local liftedT;
liftedT:=_DG([[op(T)[1][1],Q,op(T)[1][3]],op(T)[2]]);
end:

##############################################################

ndimEx:=proc(n,k,Man) local p, Bf, Bv, dimbase, Bv2, Bft, vars, g, L1, kv, Res;
# the following returns suspected n-dimensional generalizations of the special plane metrics which admit irreducible KT's, along with Killing vectors.
p:=(2*(-1)^k)/k;
DGEnvironment[Coordinate]([seq(x||i,i=1..n)],Man);
Bf:=DGinformation(Man,"FrameBaseForms");
Bv:=DGinformation(Man,"FrameBaseVectors");
dimbase:=nops(Bf);
Bft:=convert(Bf,DGtensor);
vars:=DGinformation(Man,"FrameIndependentVariables");
g:=evalDG(vars[1]^p*(add(evalDG(Bft[i] &t Bft[i]),i=1..dimbase)));
L1:=seq(seq(evalDG(-vars[i]*Bv[j] + vars[j]*Bv[i]),i=j+1..dimbase),j=2..dimbase);
kv:=[L1,seq(Bv[i],i=2..dimbase)];
Res:=[g,kv];
end:

#################################################################

Rnk2NdimEx:=proc(d,Man,{output:=[]}) local k, p, list1, list2, list3, Bf, Bv, dimbase, Bv2, Bft, vars, g, A, n, m, f, flist, f2list, o, t1, s1, r1, T1, Res, t2, r2, s2, q2, T2;
# similar to the ndimEx command, this command generates the suspected rank 2 Killing tensors which are generalizations of the 2-d examples.
k:=2;
p:=(2*(-1)^k)/k;
list1:=[seq(i,i=2..k)];
list2:=[seq(i,i=1..k)];
list3:=[seq(i,i=1..k+1)];
DGEnvironment[Coordinate]([seq(x||i,i=1..d)],Man);
Bf:=DGinformation(Man,"FrameBaseForms");
Bv:=DGinformation(Man,"FrameBaseVectors");
dimbase:=nops(Bf);
Bft:=convert(Bf,DGtensor);
vars:=DGinformation(Man,"FrameIndependentVariables");
g:=evalDG(vars[1]^p*(add(evalDG(Bft[i] &t Bft[i]),i=1..dimbase)));

#First, define the A's.

A[1][0]:=1;
A[0][0]:=0;
A[1][1]:=0;
A[0][1]:=0;
A[0][2]:=0;
A[1][2]:=0;

for n in list1 do
A[n][0]:=(k-n+3)*A[n-2][0]/(n-1);
od;

for n in list1 do
A[n][1]:=(2*A[n-1][0]+p*(k-n+3)*A[n-2][1])/(p*(n-1)-2);
od;

for n in list1 do
A[n][2]:=(2*A[n-1][1]+p*(k-n+3)*A[n-2][2])/(p*(n-1)-4);
od;

#Now, define the f's.

for m in seq(i,i=2..dimbase) do
if type(k,odd) then
for n in list2 do

if type(n,odd) then
f[n][m]:=A[n][0]*vars[m]*vars[1]^((-1)^k);
fi;

if type(n,even) then
f[n][m]:=A[n][1]*vars[1]^((-1)^k+1);
fi;

od;

f[k+1][m]:=-1/(2*k)*(k*A[k][0]-2*A[k-1][1]) + 1/k*A[k][0]*(vars[m]^2)/2*vars[1]^(-2);

fi;

if type(k,even) then
for n in list2 do

if type(n,odd) then
f[n][m]:=A[n][0]*(vars[m]^2)/2*vars[1]^((-1)^k) + A[n][2]*vars[1]^((-1)^k+2);
fi;

if type(n,even) then
f[n][m]:=A[n][1]*vars[m]*vars[1]^((-1)^k+1);
fi;

od;

f[k+1][m]:=- (A[k][1] + 2/k*A[k-1][2])*vars[1]^3 + 2/k*A[k-1][0]*vars[1]*(vars[m]^2)/2 ;

fi;

flist[m]:=[seq(f[i][m],i=list3)];
f2list[m]:=map(diff,flist[m],vars[m]);

for o in seq(i,i=m+1..dimbase) do
flist||m||o:=[seq(vars[o]*f2list[m][i],i=1..nops(f2list[m]))];
od;

od;

#now with f's defined, we construct the actual tensors.

#This first cluster defines the x1*xi^2 tensors.

for m in seq(i,i=2..dimbase) do
t1[m]:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [[[1, 1], flist[m][1]], [[1, m], flist[m][2]], [[m,m],flist[m][3]]]]);
s1[m]:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [seq([[i, i], flist[m][1]],i=2..dimbase)]]);
r1[m]:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [[[m, m], flist[m][1]]]]);
T||1[m]:=evalDG(t1[m]+s1[m]-r1[m]);
od;

#This next cluster defines the x1*xi tensors first, then the x1*xi*xj tensors.

for m in seq(i,i=2..dimbase) do
t2[m]:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [[[1, 1], f2list[m][1]], [[1, m], f2list[m][2]], [[m,m],f2list[m][3]]]]);
s2[m]:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [seq([[i, i], f2list[m][1]],i=2..dimbase)]]);
r2[m]:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [[[m, m], f2list[m][1]]]]);
T||2[m]:=evalDG(t2[m]+s2[m]-r2[m]);

for o in seq(i,i=m+1..dimbase) do
t2||m||o:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [[[1, 1], flist||m||o[1]], [[1, m], flist||m||o[2]], [[m,m],flist||m||o[3]]]]);
s2||m||o:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [seq([[i, i], flist||m||o[1]],i=2..dimbase)]]);
r2||m||o:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [[[m, m], flist||m||o[1]]]]);

q2||m||o:=_DG([["youngtensor", Man, [["cov_bas", "cov_bas"], []], [[[2], [[1, 2]]]], ["y1", "y1"], "SkewSymmetric"], [[[1, o], flist[m][2]],[[m, o], 2*op(1,flist[m][3])]]]);

T2||m||o:=evalDG(t2||m||o+s2||m||o-r2||m||o+q2||m||o);
od;

od;

#now we will put it all together. the output currently converts the young tensors to regular tensors.

if output=["DGyoungtensor"] then
Res:=[g,[seq(T||1[i],i=2..dimbase),seq(T||2[i],i=2..dimbase),seq(seq(T2||j||i,i=j+1..dimbase),j=2..dimbase)]];
else

Res:=[g,[seq(convert(T||1[i],DGtensor),i=2..dimbase),seq(convert(T||2[i],DGtensor),i=2..dimbase),seq(seq(convert(T2||j||i,DGtensor),i=j+1..dimbase),j=2..dimbase)]];

fi;
end:

#######################################################################
